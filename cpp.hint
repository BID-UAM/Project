// Hint files help the Visual Studio IDE interpret Visual C++ identifiers
// such as names of functions and macros.
// For more information see https://go.microsoft.com/fwlink/?linkid=865984
#define GDCLASS(m_class, m_inherits) private: void operator=(const m_class &p_rval) {} friend class ::godot::ClassDB; protected: virtual const ::godot::StringName *_get_extension_class_name() const override { static ::godot::StringName string_name = get_class_static(); return &string_name; } virtual const GDExtensionInstanceBindingCallbacks *_get_bindings_callbacks() const override { return &_gde_binding_callbacks; } static void (*_get_bind_methods())() { return &m_class::_bind_methods; } static void (::godot::Wrapped::*_get_notification())(int) { return (void(::godot::Wrapped::*)(int)) & m_class::_notification; } static bool (::godot::Wrapped::*_get_set())(const ::godot::StringName &p_name, const ::godot::Variant &p_property) { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name, const ::godot::Variant &p_property)) & m_class::_set; } static bool (::godot::Wrapped::*_get_get())(const ::godot::StringName &p_name, ::godot::Variant &r_ret) const { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name, ::godot::Variant &r_ret) const) & m_class::_get; } static void (::godot::Wrapped::*_get_get_property_list())(::godot::List<::godot::PropertyInfo> * p_list) const { return (void(::godot::Wrapped::*)(::godot::List<::godot::PropertyInfo> * p_list) const) & m_class::_get_property_list; } static bool (::godot::Wrapped::*_get_property_can_revert())(const ::godot::StringName &p_name) const { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name) const) & m_class::_property_can_revert; } static bool (::godot::Wrapped::*_get_property_get_revert())(const ::godot::StringName &p_name, ::godot::Variant &) const { return (bool(::godot::Wrapped::*)(const ::godot::StringName &p_name, ::godot::Variant &) const) & m_class::_property_get_revert; } static void (::godot::Wrapped::*_get_validate_property())(::godot::PropertyInfo & p_property) const { return (void(::godot::Wrapped::*)(::godot::PropertyInfo & p_property) const) & m_class::_validate_property; } static ::godot::String (::godot::Wrapped::*_get_to_string())() const { return (::godot::String(::godot::Wrapped::*)() const) & m_class::_to_string; } template <class T, class B> static void register_virtuals() { m_inherits::register_virtuals<T, B>(); } public: typedef m_class self_type; static void initialize_class() { static bool initialized = false; if (initialized) { return; } m_inherits::initialize_class(); if (m_class::_get_bind_methods() != m_inherits::_get_bind_methods()) { _bind_methods(); m_inherits::register_virtuals<m_class, m_inherits>(); } initialized = true; } static ::godot::StringName &get_class_static() { static ::godot::StringName string_name = ::godot::StringName(#m_class); return string_name; } static ::godot::StringName &get_parent_class_static() { return m_inherits::get_class_static(); } static GDExtensionObjectPtr create(void *data) { m_class *new_object = memnew(m_class); return new_object->_owner; } static GDExtensionClassInstancePtr recreate(void *data, GDExtensionObjectPtr obj) { _GDCLASS_RECREATE(m_class, m_inherits); } static void notification_bind(GDExtensionClassInstancePtr p_instance, int32_t p_what, GDExtensionBool p_reversed) { if (p_instance && m_class::_get_notification()) { if (m_class::_get_notification() != m_inherits::_get_notification()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_notification(p_what); } m_inherits::notification_bind(p_instance, p_what, p_reversed); } } static GDExtensionBool set_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionConstVariantPtr p_value) { if (p_instance && m_class::_get_set()) { if (m_class::_get_set() != m_inherits::_get_set()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_set(*reinterpret_cast<const ::godot::StringName *>(p_name), *reinterpret_cast<const ::godot::Variant *>(p_value)); } return m_inherits::set_bind(p_instance, p_name, p_value); } return false; } static GDExtensionBool get_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionVariantPtr r_ret) { if (p_instance && m_class::_get_get()) { if (m_class::_get_get() != m_inherits::_get_get()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_get(*reinterpret_cast<const ::godot::StringName *>(p_name), *reinterpret_cast<::godot::Variant *>(r_ret)); } return m_inherits::get_bind(p_instance, p_name, r_ret); } return false; } static inline bool has_get_property_list() { return m_class::_get_get_property_list() && m_class::_get_get_property_list() != m_inherits::_get_get_property_list(); } static const GDExtensionPropertyInfo *get_property_list_bind(GDExtensionClassInstancePtr p_instance, uint32_t *r_count) { if (!p_instance) { if (r_count) *r_count = 0; return nullptr; } m_class *cls = reinterpret_cast<m_class *>(p_instance); ::godot::List<::godot::PropertyInfo> &plist_cpp = cls->plist_owned; ERR_FAIL_COND_V_MSG(!plist_cpp.is_empty(), nullptr, "Internal error, property list was not freed by engine!"); cls->_get_property_list(&plist_cpp); return ::godot::internal::create_c_property_list(plist_cpp, r_count); } static void free_property_list_bind(GDExtensionClassInstancePtr p_instance, const GDExtensionPropertyInfo *p_list) { if (p_instance) { m_class *cls = reinterpret_cast<m_class *>(p_instance); cls->plist_owned.clear(); ::godot::internal::free_c_property_list(const_cast<GDExtensionPropertyInfo *>(p_list)); } } static GDExtensionBool property_can_revert_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name) { if (p_instance && m_class::_get_property_can_revert()) { if (m_class::_get_property_can_revert() != m_inherits::_get_property_can_revert()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_property_can_revert(*reinterpret_cast<const ::godot::StringName *>(p_name)); } return m_inherits::property_can_revert_bind(p_instance, p_name); } return false; } static GDExtensionBool property_get_revert_bind(GDExtensionClassInstancePtr p_instance, GDExtensionConstStringNamePtr p_name, GDExtensionVariantPtr r_ret) { if (p_instance && m_class::_get_property_get_revert()) { if (m_class::_get_property_get_revert() != m_inherits::_get_property_get_revert()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); return cls->_property_get_revert(*reinterpret_cast<const ::godot::StringName *>(p_name), *reinterpret_cast<::godot::Variant *>(r_ret)); } return m_inherits::property_get_revert_bind(p_instance, p_name, r_ret); } return false; } static GDExtensionBool validate_property_bind(GDExtensionClassInstancePtr p_instance, GDExtensionPropertyInfo *p_property) { bool ret = false; if (p_instance && m_class::_get_validate_property()) { ret = m_inherits::validate_property_bind(p_instance, p_property); if (m_class::_get_validate_property() != m_inherits::_get_validate_property()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); ::godot::PropertyInfo info(p_property); cls->_validate_property(info); info._update(p_property); return true; } } return ret; } static void to_string_bind(GDExtensionClassInstancePtr p_instance, GDExtensionBool *r_is_valid, GDExtensionStringPtr r_out) { if (p_instance && m_class::_get_to_string()) { if (m_class::_get_to_string() != m_inherits::_get_to_string()) { m_class *cls = reinterpret_cast<m_class *>(p_instance); *reinterpret_cast<::godot::String *>(r_out) = cls->_to_string(); *r_is_valid = true; return; } m_inherits::to_string_bind(p_instance, r_is_valid, r_out); } } static void free(void *data, GDExtensionClassInstancePtr ptr) { if (ptr) { m_class *cls = reinterpret_cast<m_class *>(ptr); cls->~m_class(); ::godot::Memory::free_static(cls); } } static void *_gde_binding_create_callback(void *p_token, void *p_instance) { return nullptr; } static void _gde_binding_free_callback(void *p_token, void *p_instance, void *p_binding) { } static GDExtensionBool _gde_binding_reference_callback(void *p_token, void *p_instance, GDExtensionBool p_reference) { return true; } static constexpr GDExtensionInstanceBindingCallbacks _gde_binding_callbacks = { _gde_binding_create_callback, _gde_binding_free_callback, _gde_binding_reference_callback, }; private:
